<?php

/**
 * Implementation of hook_menu().
 */
function prepro_menu() {
  return array(
    'admin/config/media/prepro' => array(
      'title' => 'Preprocessors',
      'description' => 'Configure media preprocessors',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('prepro_admin_form'),
      'access arguments' => array('administer site configuration'),
      'file' => 'prepro.admin.inc',
    ),
  );
}

function prepro_get_settings($key = false) {
  $settings = variable_get('prepro', array());
  $settings += array(
    'filetypes' => array(),
    'additional' => array(),
  );
  return $key ? $settings[$key] : $settings;
}

function prepro_get_filetype_settings($ext = false) {
  $settings = prepro_get_settings('filetypes');
  if ($ext) {
    return isset($settings[$ext]) ? $settings[$ext] : false;
  }
  return $settings;
}

function prepro_get_additional_settings($ext = false) {
  $settings = prepro_get_settings('additional');
  if ($ext) {
    return isset($settings[$ext]) ? $settings[$ext] : false;
  }
  return $settings;
}

/**
 * Helper, returns an inverted list of preprocessors, keyed by filetype.
 *
 * @ext
 *  Return file types for either just 'css' or 'js'.
 */
function _prepro_hooker($hook) {
  $types =& drupal_static(__FUNCTION__ . $hook, array());
  if (empty($types)) {
    foreach (module_implements($hook) as $module) {
      foreach (module_invoke($module, $hook) as $name => $info) {
        $info['machine_name'] = $name;
        $info['module'] = $module;
        if ($hook == 'preprocessor_info') {
          $info += array('callback' => 'preprocess_' . $name);
          foreach ($info['filetypes'] as $type) {
            $types += array($type => array());
            $types[$type][$name] = $info;
          }
        } else {
          $types[$name] = $info;
        }
      }
    }
  }
  return $types;

}
function prepro_get_compilers() {
  return _prepro_hooker('preprocessor_info');
}
function prepro_get_cachers() {
  return _prepro_hooker('preprocessor_cache_info');
}

/**
 * Implementation of hook_element_info_alter().
 */
/**
 * Passes the outgoing stylesheets list to Prepro, via hook_element_info_alter().
 * We use this instead of hook_css_alter to allow other modules to alter stuff
 * before prepro.
 */
function prepro_element_info_alter(&$type) {
  array_unshift($type['styles']['#pre_render'], 'prepro_pre_render');
}
function prepro_pre_render($elements) {
  _prepro_process_assets('css', $elements['#items']);
  return $elements;
}

function _prepro_process_assets($type, &$items) {
  $map = cache_get('prepro:map');
  $map = $map ? $map->data : array();
  $map_changed = false;

  foreach ($items as $key => $item) {
    if ($item['type'] != 'file') {
      continue;
    }

    $item += array(
      'recompile' => false,
      'target_extension' => $type,
    );

    preg_match('/([^\/]+?)\.([^\.\/]+)$/', $item['data'], $match);
    $item['basename']  = $name = $match[1]; # path/to/lol.sass => lol
    $item['extension'] = $ext = $match[2]; # path/to/lol.sass => sass
    $item['settings'] = $settings = prepro_get_filetype_settings($ext);

    foreach (array('cache_handler', 'compile_handler') as $split) {
      $compile = explode('/', isset($settings[$split]) ? $settings[$split] : '');
      $item['settings'][$split] = count($compile) == 2 ? array('module' => $compile[0], 'type' => $compile[1]) : false;
    }

    # if we can't load settings, or this filetype is explicitly not handled
    if (!$settings or !$settings['compile_handler']) {
      continue;
    }


    # calculate cache key and check if we can cache it
    $item['cache_key'] = preg_replace('/[^a-z0-9_\-\.]+/', '_', substr($item['data'], 0, -1 - strlen($ext)));
    # allow modules to alter file info here.
    drupal_alter('prepro_file', $item);
    if (isset($map[$item['cache_key']])) {
      $items[$key]['data'] = $map[$item['cache_key']];
      continue;
    }
    
    $item['cache_file'] = $item['settings']['cache_path'] . '/' . $item['cache_key'] . '.' . $item['target_extension'];
    if (!isset($map[$item['cache_key']]) || !file_exists($item['cache_file'])) {
      $item['recompile'] = true;
    }
    if (!$item['recompile'] && $item['settings']['cache_handler']) {
      $item['recompile'] = ! module_invoke($item['settings']['cache_handler']['module'], 'preprocessor_is_cached', $item, $item['settings']['cache_handler']['type']);
    }
    
    if ($item['recompile']) {
      $data = _prepro_compile($item);

      if (file_put_contents($item['cache_file'], $data) !== false) {
        $items[$key]['data'] = $item['cache_file'];
        $map[$item['cache_key']] = $item['cache_file'];
        $map_changed = true;
      }
    }
  }

  if($map_changed) {
    cache_set('prepro:map', $map, 'cache', CACHE_PERMANENT);
  }
  return $items;
}

function _prepro_compile($item) {
  $ext = $item['extension'];
  $target_ext = $item['target_extension'];
  $settings = $item['settings'];
  $compilers = prepro_get_compilers();

  if (!$settings['compile_handler']) {
    $result = file_get_contents($item['data']);
  } else {
    $settings['cache_handler']['settings'] = $settings['additional'] = $local = prepro_get_additional_settings($settings['compile_handler']['type']);

    if (!file_exists($item['data'])) {
      watchdog('Prepro', 'Prepro could not find the file %file for compilation', array('%file' => $item['data']), WATCHDOG_ERROR);
      return null;
    }

    $info = $compilers[$ext][$settings['compile_handler']['type']];
    
    $item['contents'] = file_get_contents($item['data']);
    drupal_alter('prepro_precompile', $item['contents'], $item, $local);
    drupal_alter('prepro_precompile_' . $ext, $item['contents'], $item, $local);
    drupal_alter('prepro_precompile_' . $target_ext, $item['contents'], $item, $local);
    
    $result = module_invoke($info['module'], $info['callback'], $item, $local, $settings);
    if ($result) {
      if ($target_ext === 'css') {
        _drupal_build_css_path(NULL, base_path() . dirname($item['data']) .'/');
        $result = preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $result);
      }
    }
    drupal_alter('prepro_postcompile', $result, $item, $local);
    drupal_alter('prepro_postcompile_' . $ext, $result, $item, $local);
    drupal_alter('prepro_postcompile_' . $target_ext, $result, $item, $local);
  }
  return $result;
}

/**
 * Implementation of hook_cron().
 */
function prepro_cron() {
  drupal_static('prepro_is_cron', true);
}
/**
 * Implementation of hook_flush_caches().
 */
function prepro_flush_caches() {
  $is_cron = drupal_static('prepro_is_cron', false);

  // if it's cron, then clearing the map needs to be optional.
  // if it's not, then clear the map and the files get overwritten on recompile.
  if (!$is_cron) {
    // $cache = cache_get('prepro:map', 'cache');
    // if (isset($cache, $cache->data) && $cache = $cache->data) {
    //   foreach ($cache as $hash => $file) {
    //     file_unmanaged_delete($file);
    //   }
    // }
    cache_set('prepro:map', array(), 'cache', CACHE_PERMANENT);
  }
}
